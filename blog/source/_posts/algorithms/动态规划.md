---
title: 动态规划
---

# 什么是动态规划算法
动态规划算法同分治方法相似，都是通过组合子问题的解来求解原问题。分治算法将原问题划分为互不相交的子问题，递归地求解问题，在再将子问题的解组合起来，求出原问题的解。而动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况向下，分治算法会做许多不必要的计算，它会反复计算公共子问题。而动态规划算法对公共子问题只求解一次，然后将其解保存在一个表格中，避免了不必要的计算。
**动态规划算法通常用来求解最优化问题。**
动态规划算法的设计步骤：
1. 刻画一个最优解的结构特征
2. 递归地定义最优解的值
3. 计算最优解的值，通常采用自底向上的方法
4. 利用计算出的信息构造一个解。

# 动态规划原理
动态规划算法就是将递归算法重复计算子问题的计算结果保留，这样可以避免重复计算子问题。
从工程角度看，在什么情况下应该使用动态规划算法求解问题呢？
适合应用动态规划算法求解的最优化问题，应该具备两个要素：最优子结构和子问题重叠。
## 最优子结构
用动态规划求解最优问题的第一步就是刻画最优解的结构。**如果一个问题的最优解包含子问题的最优解，我们就称此问题具有最优子结构性质。**具有最优子结构是使用动态规划算法的标志。
发掘最优子结构性质可以采用如下通用模式：
1. 证明问题最优解的第一个组成部分是做出一个选择，做出这个选择后会产生一个或者多个待解的子问题
2. 给定一个问题，在其可能的第一步选择中，假定已经知道哪种选择才会得到最优解。
3. 给定可获得的最优解后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。
4. 用“剪切-粘贴”的技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。可以利用反正法：假定子问题的解不是其自身的最优解，那么我们就可以从原问题的解中“剪切”掉这些非最优解，将最优解“粘贴”进去，从而得到原问题的一个更优解，这与最初的解是原问题的最优解的前提假设矛盾。
一个刻画问题的好经验就是：**保持子问题空间尽量简单，只有在必要时才扩展它。**（使用几维数组保存子问题的解）

# 钢条切割
钢条切割问题：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,...,n)，求钢条的切割方案，使得销售收益rn最大。价格表如下：

长度 | 1 | 2| 3| 4| 5| 6| 7| 8| 9| 10
:---|:--|:-|:--|:--|:--|:--|:--|:-|:-|:-
价格| 1  | 5|8|9|10|17|17|20|24|30

长度为n英寸的钢条共有 2^(n-1) 种不同的切割方案，因为在距离钢条左端i英寸处，可以选择切割或不切割。我们用加号表示切割方案，7=2+2+3 表示将长度为7的钢条切成三段。如果最优解将钢条切割为k段(1≤k≤n)，那么最优的切割方案
    n = i(1) + i(2) + ... + i(k)
该方案的最大收益是
    r(n) = p(i1) + p(i2) + ... + p(ik)
更直接的，我们可以将钢条的最优切割收益记做：
    r(n) = max(p(n), r(1) + r(n-1), r(2) + r(n-2), ..., r(n-1) + r(1))
第一个参数p(n)对应不切割，直接出售长度为n的钢条的方案。其他n-1个参数对应另外n-1种方案：对于每个i=1,2...,n-1,首先将钢条切割成长度为i和n-i的两段，接着求解这两段的最优切割收益r(i)和r(n-i)，因为无法预知哪种方案会获得最优收益，我们需要考虑所有可能的i，选择其中收益最大者。
为了求解规模为n的原问题，我们先求解形式完全一样，但规模更小的子问题。即当完成首次切割以后，我们将两段钢条看成两个独立的钢条切割问题，通过组合两个相关子问题的最优解，并在所有可能的两段切割方案中选区组合收益最大者，构成原问题的解，该问题是满足最优子结构的。
我们首先使用递归方式求解该问题，其递归式可以写为： r(n) = max (p(i) + r(n-i)) 1≤i≤n
其伪代码如下：
```
CUT-ROD(p,n)
    if n == 0
        return 0
    q = -∞
    for i=1 to n
        q = max(q, p[i] + CUT-ROD(p, n-i))
    return q
```
该算法的时间复杂度是 2^n。可以看到该算法反复地用相同的参数值对自身进行递归调用，即它反复地求解相同的子问题。而动态规划算法可以仔细安排求解顺序，对每个子问题都只求解一次，并将结果保持下来。如果随后需要再次使用该解，只需查询保存的结果，而不必重新计算。动态规划是用额外的存储空间来节省时间的算法，可能将一个指数时间的解转化成一个多项式时间的解。

## 使用动态规划方法求解最优钢条切割问题
朴素递归算法之所以效率很低，是因为它反复地求解相同的子问题。**动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来**。如果随后要在此需要子问题的解，只需要查询保存的结果，而不用重新计算。**动态规划算法付出额外的内存空间来节省时间**
动态规划有两种等价的实现方式：
1. **带备忘录的自顶向下法**。 此方法仍按自然的递归形式编写过程，但过程中会保存每个子问题的解（数组或散列表等）。当需要一个子问题的解时，首先检查是否已经保存过此解，从而节省计算时间。
    
    ```
    MEMOIZED-CUT-ROD(p, u) 
        let r[0...n] be a new array
        for i=0 to n
            r[i] = -∞
        return MEMOIZED-CUT-ROD-AUX(p, n, r)

    MEMOIZED-CUT-ROD-AUX(p, n, r)
        if r[n] ≥ 0
            return r[n]
        if n == 0
            q = 0
        else 
            q = -∞
            for i=1 to n
                q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i, r))
    ```
2. **自底向上法**。 此方法一般需要恰当定义子问题的“规模”，使得任何子问题的求解都只依赖于“更小的”子问题的解。因此我们将子问题按照规模排序，按由小到大的顺序求解。当求解某个问题时，它所依赖的那些更小的子问题都已经求解完毕，结果已经保存，每个子问题都只需要求解一次。
    ```
    BOTTOM-UP-ROD(p, n)
        let r[0...n] and s[0...n] be a new array
        n[0] = 0;
        for j=1 to n
            q = -∞
            for i=1 to j
                if q < p[i] + r[j-i]
                    q =  p[i] + r[j-i]
                    s[j] = i;
                r[j] = q
        return r and s
    ```

这两种方法具有渐近运行时间，由于没有频繁的递归函数调用开销，自底向上法的时间复杂度具有更小的系数。

### 子问题图
当考虑一个动态规划问题时，我们应该弄清楚所设计的子问题以及子问题之间的依赖关系。
问题的子问题图准确地表达了问题间的依赖关系。它是一个有向图，每个顶点唯一地对应一个子问题。若子问题x的最优解需要直接用到子问题y的最优解，那么久会在子问题图中有一条从子问题x到子问题y的顶点的有向边。
{% raw %}
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="processonSvg1000" viewBox="224.6 102.0 238.4 313.0" width="100%" height="100%"><defs id="ProcessOnDefs1001"><marker id="ProcessOnMarker1023" markerUnits="userSpaceOnUse" orient="auto" markerWidth="14.118033988749895" markerHeight="9.174454630060925" viewBox="-0.5 -0.6881909602355868 14.118033988749895 9.174454630060925" refX="-0.5" refY="3.8990363547948754"><path id="ProcessOnPath1024" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="1.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1027" markerUnits="userSpaceOnUse" orient="auto" markerWidth="14.118033988749895" markerHeight="9.174454630060925" viewBox="-0.5 -0.6881909602355868 14.118033988749895 9.174454630060925" refX="-0.5" refY="3.8990363547948754"><path id="ProcessOnPath1028" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="1.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1031" markerUnits="userSpaceOnUse" orient="auto" markerWidth="14.118033988749895" markerHeight="9.174454630060925" viewBox="-0.5 -0.6881909602355868 14.118033988749895 9.174454630060925" refX="-0.5" refY="3.8990363547948754"><path id="ProcessOnPath1032" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="1.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1035" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1036" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="2.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1039" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1040" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="2.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1047" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1048" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="2.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1051" markerUnits="userSpaceOnUse" orient="auto" markerWidth="14.118033988749895" markerHeight="9.174454630060925" viewBox="-0.5 -0.6881909602355868 14.118033988749895 9.174454630060925" refX="-0.5" refY="3.8990363547948754"><path id="ProcessOnPath1052" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="1.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1055" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1056" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="2.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1059" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1060" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="2.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker><marker id="ProcessOnMarker1063" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1064" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#323232" stroke-width="2.0" fill="#323232" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"/></marker></defs><g id="ProcessOnG1002"><path id="ProcessOnPath1003" d="M224.6 102.0H463.0V415.0H224.6V102.0Z" fill="none"/><g id="ProcessOnG1004"><g id="ProcessOnG1005" transform="matrix(1.0,0.0,0.0,1.0,341.0,183.0)" opacity="1.0"><path id="ProcessOnPath1006" d="M0.0 16.0C0.0 -5.333333333333333 30.0 -5.333333333333333 30.0 16.0C30.0 37.333333333333336 0.0 37.333333333333336 0.0 16.0Z" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="#c0d4a3"/><g id="ProcessOnG1007" transform="matrix(1.0,0.0,0.0,1.0,10.0,7.875)"><text id="ProcessOnText1008" fill="#323232" font-size="13" x="4.0" y="13.325" font-family="Arial" font-weight="bold" font-style="normal" text-decoration="none" family="Arial" text-anchor="middle" size="13">3</text></g></g><g id="ProcessOnG1009" transform="matrix(1.0,0.0,0.0,1.0,341.0,243.0)" opacity="1.0"><path id="ProcessOnPath1010" d="M0.0 16.0C0.0 -5.333333333333333 30.0 -5.333333333333333 30.0 16.0C30.0 37.333333333333336 0.0 37.333333333333336 0.0 16.0Z" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="#c0d4a3"/><g id="ProcessOnG1011" transform="matrix(1.0,0.0,0.0,1.0,10.0,7.875)"><text id="ProcessOnText1012" fill="#323232" font-size="13" x="4.0" y="13.325" font-family="Arial" font-weight="bold" font-style="normal" text-decoration="none" family="Arial" text-anchor="middle" size="13">2</text></g></g><g id="ProcessOnG1013" transform="matrix(1.0,0.0,0.0,1.0,341.0,304.0)" opacity="1.0"><path id="ProcessOnPath1014" d="M0.0 16.0C0.0 -5.333333333333333 30.0 -5.333333333333333 30.0 16.0C30.0 37.333333333333336 0.0 37.333333333333336 0.0 16.0Z" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="#c0d4a3"/><g id="ProcessOnG1015" transform="matrix(1.0,0.0,0.0,1.0,10.0,7.875)"><text id="ProcessOnText1016" fill="#323232" font-size="13" x="4.0" y="13.325" font-family="Arial" font-weight="bold" font-style="normal" text-decoration="none" family="Arial" text-anchor="middle" size="13">1</text></g></g><g id="ProcessOnG1017" transform="matrix(1.0,0.0,0.0,1.0,341.0,122.0)" opacity="1.0"><path id="ProcessOnPath1018" d="M0.0 16.0C0.0 -5.333333333333333 30.0 -5.333333333333333 30.0 16.0C30.0 37.333333333333336 0.0 37.333333333333336 0.0 16.0Z" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="#c0d4a3"/><g id="ProcessOnG1019" transform="matrix(1.0,0.0,0.0,1.0,10.0,7.875)"><text id="ProcessOnText1020" fill="#323232" font-size="13" x="4.0" y="13.325" font-family="Arial" font-weight="bold" font-style="normal" text-decoration="none" family="Arial" text-anchor="middle" size="13">4</text></g></g><g id="ProcessOnG1021"><path id="ProcessOnPath1022" d="M356.0 154.0C356.0 165.6 356.0 171.4 356.0 169.3819660112501" stroke="#323232" stroke-width="1.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1023)"/></g><g id="ProcessOnG1025"><path id="ProcessOnPath1026" d="M356.0 215.0C356.0 226.2 356.0 231.8 356.0 229.3819660112501" stroke="#323232" stroke-width="1.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1027)"/></g><g id="ProcessOnG1029"><path id="ProcessOnPath1030" d="M356.0 275.0C356.0 286.6 356.0 292.4 356.0 290.3819660112501" stroke="#323232" stroke-width="1.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1031)"/></g><g id="ProcessOnG1033"><path id="ProcessOnPath1034" d="M341.0 138.0C292.6 138.0 292.6 259.0 325.7639320225002 259.0" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1035)"/></g><g id="ProcessOnG1037"><path id="ProcessOnPath1038" d="M341.0 138.0C268.2 138.0 268.2 320.0 325.7639320225002 320.0" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1039)"/></g><g id="ProcessOnG1041" transform="matrix(1.0,0.0,0.0,1.0,341.0,363.0)" opacity="1.0"><path id="ProcessOnPath1042" d="M0.0 16.0C0.0 -5.333333333333333 30.0 -5.333333333333333 30.0 16.0C30.0 37.333333333333336 0.0 37.333333333333336 0.0 16.0Z" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="#c0d4a3"/><g id="ProcessOnG1043" transform="matrix(1.0,0.0,0.0,1.0,10.0,7.875)"><text id="ProcessOnText1044" fill="#323232" font-size="13" x="4.0" y="13.325" font-family="Arial" font-weight="bold" font-style="normal" text-decoration="none" family="Arial" text-anchor="middle" size="13">0</text></g></g><g id="ProcessOnG1045"><path id="ProcessOnPath1046" d="M341.0 138.0C244.6 138.0 244.6 379.0 325.7639320225002 379.0" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1047)"/></g><g id="ProcessOnG1049"><path id="ProcessOnPath1050" d="M356.0 336.0C356.0 346.8 356.0 352.2 356.0 349.3819660112501" stroke="#323232" stroke-width="1.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1051)"/></g><g id="ProcessOnG1053"><path id="ProcessOnPath1054" d="M371.0 199.0C419.4 199.0 419.4 320.0 386.2360679774998 320.0" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1055)"/></g><g id="ProcessOnG1057"><path id="ProcessOnPath1058" d="M371.0 199.0C443.0 199.0 443.0 379.0 386.2360679774998 379.0" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1059)"/></g><g id="ProcessOnG1061"><path id="ProcessOnPath1062" d="M341.0 259.0C293.0 259.0 293.0 379.0 325.7639320225002 379.0" stroke="#323232" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1063)"/></g></g></g></svg>
{%endraw%}

子问题图 G=(V, E) 的规模可以帮助我们确定动态规划算法的运行时间，由于每个子问题只求解一次，因此算法运行时间等于每个子问题求解时间之和。通常，一个子问题的求解时间与子问题图中对应顶点的度（出射边的数目）成正比，而子问题的数目等于子问题图的顶点数。因此，**动态规划算法的运行时间与定点和边的数量呈线性关系。

### 重构解
在上述的 `BOTTOM-UP-CUT-ROD` 中，我们通过数组`s`保存了每个子问题的最优收益值。我们可以通过如下方式获取最优切割方案：
```
PRINT-CUT-ROD-SOLUTION (p, n) 
    (r,s) = BOTTOM-UP-CUT-ROD(p,n)
    while n > 0
        print s[n]
        n = n - s[n]
```
